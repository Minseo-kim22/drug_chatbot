import pandas as pd
import re

# 1. 데이터 로드 및 전처리
# .py 스크립트와 동일한 폴더에 있는 'druglist.csv' 파일을 사용합니다.
file_path = r'druglist.csv' 
try:
    # 파일이 UTF-8로 변환되었으므로 'utf-8'로 읽어옵니다.
    df = pd.read_csv(file_path, encoding='utf-8')
    df['상세정보'] = df['상세정보'].fillna('상호작용 정보 없음')
    print("✅ 약물 상호작용 데이터 로드 성공!")
except FileNotFoundError:
    print(f"❌ '{file_path}' 파일을 찾을 수 없습니다. 경로를 확인해주세요.")
    print("   (파일을 .py 파일과 같은 폴더에 넣고, 파일 이름을 확인해주세요!)")
    exit()
except UnicodeDecodeError:
    # UTF-8로 읽기 실패 시
    print(f"❌ '{file_path}' 파일의 인코딩 형식을 확인해주세요. (UTF-8로 읽기 실패)")
    print("   (파일을 메모장으로 열어 '다른 이름으로 저장' -> 인코딩을 'UTF-8'로 변경 후 시도해보세요.)")
    exit()
except Exception as e:
    print(f"❌ 파일 로드 중 오류 발생: {e}")
    exit()


# 2. 유연한 약물 정보 검색 함수
def find_drug_info(df, query):
    """사용자 쿼리로부터 약물 관련 정보를 유연하게 검색합니다."""
    # 쿼리 전처리: 괄호, 용량 정보, 제형 관련 단어 제거
    cleaned_query = re.sub(r'\(.*?\)|\[.*?\]|\d+m?g?l?|주사제|정제|정|약|캡슐|시럽', '', query).strip()
    if not cleaned_query:
        return pd.DataFrame() # 빈 쿼리 처리

    try:
        # 모든 약물 관련 컬럼에서 쿼리 검색 (대소문자 무시)
        search_pattern = re.escape(cleaned_query) # 특수문자 이스케이프
        search_results = df[
            df['제품명A'].str.contains(search_pattern, na=False, case=False) |
            df['성분명A'].str.contains(search_pattern, na=False, case=False) |
            df['제품명B'].str.contains(search_pattern, na=False, case=False) |
            df['성분명B'].str.contains(search_pattern, na=False, case=False)
        ]
    except Exception as e:
        print(f"DEBUG: find_drug_info에서 오류 발생 - {e}")
        return pd.DataFrame()

    return search_results

# 3. 약물 상호작용 평가 함수
def check_drug_interaction_flexible(df, drug_A_query, drug_B_query):
    """두 약물 쿼리에 대해 상호작용 위험도를 평가합니다."""
    
    results_A = find_drug_info(df, drug_A_query)
    results_B = find_drug_info(df, drug_B_query)

    if results_A.empty:
        return "정보 없음", f"'{drug_A_query}'에 대한 약물 정보를 찾을 수 없습니다."
    if results_B.empty:
        return "정보 없음", f"'{drug_B_query}'에 대한 약물 정보를 찾을 수 없습니다."

    # 검색된 약물들의 고유한 제품명/성분명 집합 생성
    drugs_A = set(results_A['제품명A']).union(set(results_A['성분명A'])).union(set(results_A['제품명B'])).union(set(results_A['성분명B']))
    drugs_B = set(results_B['제품명A']).union(set(results_B['성분명A'])).union(set(results_B['제품명B'])).union(set(results_B['성분명B']))

    # NaN 값 제거
    drugs_A.discard(pd.NA)
    drugs_A.discard(None)
    drugs_B.discard(pd.NA)
    drugs_B.discard(None)
    
    # 쿼리 자체도 검색 대상에 포함 (전처리된 쿼리 사용)
    cleaned_A = re.sub(r'\(.*?\)|\[.*?\]|\d+m?g?l?|주사제|정제|정|약|캡슐|시럽', '', drug_A_query).strip()
    cleaned_B = re.sub(r'\(.*?\)|\[.*?\]|\d+m?g?l?|주사제|정제|정|약|캡슐|시럽', '', drug_B_query).strip()
    if cleaned_A: drugs_A.add(cleaned_A)
    if cleaned_B: drugs_B.add(cleaned_B)

    interactions = pd.DataFrame()

    # df에서 (drug_A, drug_B) 또는 (drug_B, drug_A) 조합 찾기
    for a in drugs_A:
        for b in drugs_B:
            if a == b or not a or not b: continue # 같은 약물 비교, 빈 문자열 건너뜀
            
            try:
                a_pattern = re.escape(str(a))
                b_pattern = re.escape(str(b))

                # (A, B) 조합 검색 (대소문자 무시)
                interaction_rows_1 = df[
                    (df['제품명A'].str.contains(a_pattern, na=False, case=False) | df['성분명A'].str.contains(a_pattern, na=False, case=False)) &
                    (df['제품명B'].str.contains(b_pattern, na=False, case=False) | df['성분명B'].str.contains(b_pattern, na=False, case=False))
                ]
                
                # (B, A) 조합 검색 (대소문자 무시)
                interaction_rows_2 = df[
                    (df['제품명A'].str.contains(b_pattern, na=False, case=False) | df['성분명A'].str.contains(b_pattern, na=False, case=False)) &
                    (df['제품명B'].str.contains(a_pattern, na=False, case=False) | df['성분명B'].str.contains(a_pattern, na=False, case=False))
                ]
                
                if not interaction_rows_1.empty:
                    interactions = pd.concat([interactions, interaction_rows_1])
                if not interaction_rows_2.empty:
                    interactions = pd.concat([interactions, interaction_rows_2])
            except re.error as e:
                print(f"DEBUG: 정규식 오류 발생 (a='{a}', b='{b}') - {e}")
                continue


    if interactions.empty:
        return "안전", f"'{drug_A_query}'와 '{drug_B_query}' 간의 상호작용 정보가 없습니다."

    # 중복 제거
    interactions = interactions.drop_duplicates()

    # 위험도 판단 로직 (키워드)
    dangerous_keywords = ["금기", "투여 금지", "독성 증가", "치명적인", "심각한", "유산 산성증", "고칼륨혈증", "심실성 부정맥", "위험성 증가", "위험 증가", "심장 부정맥", "QT간격 연장 위험 증가", "QT연장", "심부정맥", "중대한", "심장 모니터링", "병용금기", "Torsade de pointes 위험 증가", "위험이 증가함", "약물이상반응 발생 위험", "독성", "허혈", "혈관경련", ]
    caution_keywords = ["치료 효과가 제한적", "중증의 위장관계 이상반응", "Alfuzosin 혈중농도 증가", "양쪽 약물 모두 혈장농도 상승 가능", "Amiodarone 혈중농도 증가", "혈중농도 증가", "횡문근융해와 같은 중증의 근육이상 보고",  "혈장 농도 증가", "Finerenone 혈중농도의 현저한 증가가 예상됨"]


    risk_level = "안전" # 기본값
    reasons = []
    processed_details = set() # 중복된 상세정보 출력을 막기 위함

    for detail in interactions['상세정보'].unique():
        if detail in processed_details:
            continue
        
        detail_str = str(detail)
        processed_details.add(detail)
        
        found_danger = False
        for keyword in dangerous_keywords:
            if keyword in detail_str:
                risk_level = "위험" # 위험 키워드가 하나라도 있으면 '위험'
                reasons.append(f"🚨 위험: {detail_str}")
                found_danger = True
                break # 이 상세정보는 '위험'으로 확정
        
        if not found_danger:
            for keyword in caution_keywords:
                if keyword in detail_str:
                    if risk_level != "위험": # '위험'이 아닐 때만 '주의'로 설정
                        risk_level = "주의"
                    reasons.append(f"⚠️ 주의: {detail_str}")
                    break # '주의' 키워드 하나 찾으면 다음 상세정보로
    
    if not reasons:
        # 상호작용은 있으나, 키워드에 걸리지 않은 경우
        risk_level = "정보 확인"
        reasons.append("ℹ️ 상호작용 정보가 있으나, 지정된 위험/주의 키워드는 발견되지 않았습니다. 전문가와 상담하세요.")
        # 참고용으로 모든 상세정보를 보여줍니다.
        for detail in interactions['상세정보'].unique():
             if str(detail) not in processed_details: # 이미 추가된 것 제외
                reasons.append(f"ℹ️ 정보: {str(detail)}")
            

    return risk_level, "\n".join(reasons)

# 4. 챗봇 인터페이스 (콘솔 기반)
def start_chatbot():
    """콘솔에서 사용자와 상호작용하는 챗봇을 시작합니다."""
    print("="*50)
    print("안녕하세요! 약물 상호작용 챗봇입니다.")
    print("두 약물을 함께 복용해도 되는지, 혹은 약물의 성분을 알려드릴 수 있습니다.")
    print("\n[질문 예시]")
    print("1. (A)약물과 (B)약물을 같이 복용해도 돼?")
    print("2. (A)약물 성분이 뭐야?")
    print("\n종료하려면 '종료' 또는 'exit'을 입력하세요.")
    print("="*50)

    while True:
        user_input = input("\n👉 질문을 입력하세요: ")
        if user_input.lower() in ['종료', 'exit']:
            print("\n챗봇을 종료합니다. 감사합니다! 💊")
            break

        # 질문 유형 분석
        
        # 1. 성분 질문
        # 예: "타이레놀 성분이 뭐야?", "타이레놀 성분 알려줘"
        match_component = re.match(r'(.+?)(?: 성분이 뭐야| 성분 뭐야| 성분 알려줘)\??', user_input)
        if match_component:
            drug_name = match_component.group(1).strip('() ').strip()
            if drug_name:
                results = find_drug_info(df, drug_name)
                if not results.empty:
                    components = set()
                    
                    # 검색된 약물과 매칭되는 성분 찾기
                    pattern = re.escape(drug_name)
                    
                    for _, row in results.iterrows():
                        # 제품명A/B가 쿼리와 일치하면, 성분명A/B를 추가
                        if pd.notna(row['제품명A']) and re.search(pattern, row['제품명A'], re.IGNORECASE):
                            if pd.notna(row['성분명A']): components.add(row['성분명A'])
                        if pd.notna(row['제품명B']) and re.search(pattern, row['제품명B'], re.IGNORECASE):
                            if pd.notna(row['성분명B']): components.add(row['성분명B'])
                        # 성분명A/B가 쿼리와 일치하면, 해당 성분명을 추가
                        if pd.notna(row['성분명A']) and re.search(pattern, row['성분명A'], re.IGNORECASE):
                            components.add(row['성분명A'])
                        if pd.notna(row['성분명B']) and re.search(pattern, row['성분명B'], re.IGNORECASE):
                            components.add(row['성분명B']) # '성F분명B' 오타 수정

                    if components:
                        print(f"✅ '{drug_name}'의 관련 성분은 다음과 같습니다: {', '.join(components)}")
                    else:
                        print(f"ℹ️ '{drug_name}'을(를) 찾았으나, 연관된 성분 정보를 추출하지 못했습니다.")
                else:
                    print(f"❌ '{drug_name}' 정보를 찾을 수 없습니다.")
            else:
                print("❌ 어떤 약물의 성분을 알고 싶으신가요? 약물 이름을 입력해주세요.")
        
        # 2. 상호작용 질문
        # 예: "타이레놀과 아스피린을 같이 복용해도 돼?"
        # 예: "타이레놀 아스피린 같이 먹어도 돼"
        # 예: "타이레놀이랑 아스피린" (간단한 형태)
        match_interaction = re.match(r'(.+?)(?:과|와|랑|하고)\s+(.+?)(?:를|을)?\s+(?:같이|함께)\s+(?:복용해도|먹어도)\s+(?:돼|되나|될까|되나요)\??', user_input)
        
        if not match_interaction:
             # 간단한 형태: "약물A 약물B"
             match_interaction_simple = re.match(r'^\s*([^\s]+)\s+([^\s]+)\s*$', user_input)
             if match_interaction_simple:
                 match_interaction = match_interaction_simple # 동일한 로직으로 처리

        if match_interaction:
            drug_A_query = match_interaction.group(1).strip('() ').strip()
            drug_B_query = match_interaction.group(2).strip('() ').strip()
            
            if drug_A_query and drug_B_query:
                print(f"🔄 '{drug_A_query}'와 '{drug_B_query}'의 상호작용을 검색합니다...")
                risk, explanation = check_drug_interaction_flexible(df, drug_A_query, drug_B_query)
                print("\n" + "="*20 + " [검색 결과] " + "="*20)
                print(f"**💊 약물 상호작용 위험도: {risk}**")
                print(f"**💡 상세 정보:**")
                print(explanation)
                print("="*52)
            else:
                print("❌ 두 약물 이름을 정확히 입력해주세요. 예: (A)약물과 (B)약물을 같이 복용해도 돼?")
        
        # 아무 패턴에도 해당하지 않는 경우
        elif not match_component:
            print("🤔 죄송합니다. 질문 형식을 이해하지 못했습니다.")
            print("   예: (타이레놀)과 (아스피린)을 같이 복용해도 돼?")
            print("   예: (타이레놀) 성분이 뭐야?")

# 챗봇 시작
if __name__ == "__main__":
    start_chatbot()
```eof
