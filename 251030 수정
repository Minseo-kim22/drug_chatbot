import streamlit as st
import pandas as pd
import re

# 1. 데이터 로드 (페이지가 로드될 때 한 번만 실행됨)
@st.cache_data
def load_data():
    """druglist.csv 파일을 로드하고 캐시에 저장합니다."""
    file_path = r'druglist.csv'
    try:
        # UTF-8로 파일을 읽습니다.
        df = pd.read_csv(file_path, encoding='utf-8')
        df['상세정보'] = df['상세정보'].fillna('상호작용 정보 없음')
        print("✅ (Streamlit) 약물 상호작용 데이터 로드 성공!")
        # [성능개선] 검색을 위해 모든 텍스트 컬럼을 미리 'str' 타입으로 변경
        for col in ['제품명A', '성분명A', '제품명B', '성분명B']:
            df[col] = df[col].astype(str).str.lower() # 소문자로 통일
        return df
    except FileNotFoundError:
        st.error(f"❌ '{file_path}' 파일을 찾을 수 없습니다. .py 파일과 같은 폴더에 있는지 확인해주세요.")
        return None
    except UnicodeDecodeError:
        st.error(f"❌ '{file_path}' 파일 인코딩이 'utf-8'이 아닌 것 같습니다. (파일 인코딩을 'utf-8'로 변환해주세요)")
        return None
    except Exception as e:
        st.error(f"❌ 파일 로드 중 오류 발생: {e}")
        return None

# 데이터 로드 실행
df = load_data()

# 2. 약물 검색 및 상호작용 함수들
def find_drug_info(df, query):
    """(수정) 사용자 쿼리로부터 약물 관련 정보를 유연하게 검색합니다."""
    
    # 쿼리 전처리: 괄호 및 특정 제형 단어만 제거
    cleaned_query = re.sub(r'\(.*?\)|\[.*?\]|주사제|정제|캡슐|시럽', '', query).strip().lower() # 소문자로 통일
    
    if not cleaned_query:
        return pd.DataFrame(), None # 빈 쿼리 처리
    
    try:
        search_pattern = re.escape(cleaned_query)
        # [수정] 미리 소문자화된 컬럼에서 검색
        search_results = df[
            df['제품명A'].str.contains(search_pattern, na=False) |
            df['성분명A'].str.contains(search_pattern, na=False) |
            df['제품명B'].str.contains(search_pattern, na=False) |
            df['성분명B'].str.contains(search_pattern, na=False)
        ]
        # [수정] 검색된 약물의 모든 이름/성분 집합을 반환
        if search_results.empty:
            return pd.DataFrame(), None # 검색 결과 없음
        
        drugs_set = set(search_results['제품명A']).union(set(search_results['성분명A'])).union(set(search_results['제품명B'])).union(set(search_results['성분명B']))
        drugs_set.discard('nan') # 'nan' 문자열 제거
        drugs_set.add(cleaned_query) # 원본 쿼리도 추가
        
        return search_results, drugs_set

    except Exception as e:
        print(f"DEBUG: find_drug_info에서 오류 발생 - {e}")
        return pd.DataFrame(), None
    

def check_drug_interaction_flexible(df, drug_A_query, drug_B_query):
    """ [성능개선] 두 약물 쿼리에 대해 상호작용 위험도를 평가합니다. (중첩 반복문 제거) """
    
    # 1. 각 약물에 대한 정보 및 관련 이름/성분 집합(set) 찾기
    results_A, drugs_A_set = find_drug_info(df, drug_A_query)
    results_B, drugs_B_set = find_drug_info(df, drug_B_query)

    # [수정-P2] 약물 검색 결과에 따른 메시지 분기
    if results_A.empty:
        return "정보 없음", f"'{drug_A_query}'" # 실패한 약물 이름 반환
    if results_B.empty:
        return "정보 없음", f"'{drug_B_query}'" # 실패한 약물 이름 반환

    # 2. [성능개선] 각 약물 집합(set)을 '|' (OR) 정규식 패턴으로 변환
    #    'nan'이나 빈 문자열이 아닌 유효한 항목만 필터링
    valid_drugs_A = [re.escape(str(d)) for d in drugs_A_set if pd.notna(d) and str(d).strip()]
    valid_drugs_B = [re.escape(str(d)) for d in drugs_B_set if pd.notna(d) and str(d).strip()]

    if not valid_drugs_A or not valid_drugs_B:
        return "정보 없음", f"'{drug_A_query}' 또는 '{drug_B_query}'" # 유효한 검색어가 없는 경우

    pattern_A = '|'.join(valid_drugs_A)
    pattern_B = '|'.join(valid_drugs_B)

    try:
        # 3. [성능개선] 단 4번의 vectorized (매우 빠른) 검색으로 상호작용 찾기
        
        # (A, B) 조합이 있는지 확인
        col_A_match = df['제품명A'].str.contains(pattern_A, na=False) | df['성분명A'].str.contains(pattern_A, na=False)
        col_B_match = df['제품명B'].str.contains(pattern_B, na=False) | df['성분명B'].str.contains(pattern_B, na=False)
        
        # (B, A) 조합이 있는지 확인
        col_A_match_rev = df['제품명A'].str.contains(pattern_B, na=False) | df['성분명A'].str.contains(pattern_B, na=False)
        col_B_match_rev = df['제품명B'].str.contains(pattern_A, na=False) | df['성분명B'].str.contains(pattern_A, na=False)
        
        # 두 조합의 결과를 합침
        interactions = df[ (col_A_match & col_B_match) | (col_A_match_rev & col_B_match_rev) ]

    except re.error as e:
        print(f"DEBUG: 정규식 오류 발생 - {e}")
        return "오류", "검색 중 정규식 오류가 발생했습니다. (너무 많은 약물이 검색됨)"
    except Exception as e:
        print(f"DEBUG: 상호작용 검색 중 오류 - {e}")
        return "오류", "상호작용 검색 중 오류가 발생했습니다."


    if interactions.empty:
        # [수정-P2] 약물은 찾았으나, 상호작용이 없는 경우
        return "안전", f"'{drug_A_query}'와 '{drug_B_query}' 간의 **등록된 상호작용 정보**가 없습니다."

    # 중복 제거
    interactions = interactions.drop_duplicates(subset=['상세정보'])

    # 4. 위험도 판단 로직 (기존과 동일)
    dangerous_keywords = ["금기", "투여 금지", "독성 증가", "치명적인", "심각한", "유산 산성증", "고칼륨혈증", "심실성 부정맥", "위험성 증가", "위험 증가", "심장 부정맥", "QT간격 연장 위험 증가", "QT연장", "심부정맥", "중대한", "심장 모니터링", "병용금기", "Torsade de pointes 위험 증가", "위험이 증가함", "약물이상반응 발생 위험", "독성", "허혈", "혈관경련", ]
    caution_keywords = ["치료 효과가 제한적", "중증의 위장관계 이상반응", "Alfuzosin 혈중농도 증가", "양쪽 약물 모두 혈장농도 상승 가능", "Amiodarone 혈중농도 증가", "혈중농도 증가", "횡문근융해와 같은 중증의 근육이상 보고",  "혈장 농도 증가", "Finerenone 혈중농도의 현저한 증가가 예상됨"]

    risk_level = "안전" # 기본값
    reasons = []
    processed_details = set() 

    for detail in interactions['상세정보'].unique():
        if detail in processed_details: continue
        detail_str = str(detail)
        processed_details.add(detail)
        
        found_danger = False
        for keyword in dangerous_keywords:
            if keyword in detail_str:
                risk_level = "위험" 
                reasons.append(f"🚨 **위험**: {detail_str}")
                found_danger = True
                break 
        
        if not found_danger:
            for keyword in caution_keywords:
                if keyword in detail_str:
                    if risk_level != "위험": risk_level = "주의"
                    reasons.append(f"⚠️ **주의**: {detail_str}")
                    break 
    
    if not reasons:
        risk_level = "정보 확인"
        reasons.append("ℹ️ 상호작용 정보가 있으나, 지정된 위험/주의 키워드는 발견되지 않았습니다. 전문가와 상담하세요.")
        for detail in interactions['상세정보'].unique():
             if str(detail) not in processed_details:
                reasons.append(f"ℹ️ **정보**: {str(detail)}")
            
    return risk_level, "\n\n".join(reasons)

# 3. Streamlit 웹사이트 UI 코드
st.title("💊 약물 상호작용 챗봇")
st.caption("캡스톤 프로젝트: 약물 상호작용 정보 검색 챗봇")

# 채팅 기록을 st.session_state에 저장하여 유지
if "messages" not in st.session_state:
    st.session_state.messages = []

# 채팅 기록이 비어있으면, 초기 안내 메시지 추가
if not st.session_state.messages:
    st.session_state.messages.append(
        {"role": "assistant", "content": "안녕하세요! 약물 상호작용 챗봇입니다.\n\n[질문 예시]\n1. 타이레놀 성분이 뭐야?\n2. 타이레놀과 아스피린을 같이 복용해도 돼?"}
    )

# 이전 채팅 기록을 화면에 표시
for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

# 데이터 로드에 실패했으면, 챗봇 입력을 막음
if df is None:
    st.error("데이터 로드 실패로 챗봇을 실행할 수 없습니다.")
else:
    # 4. 사용자 채팅 입력 받기
    if prompt := st.chat_input("질문을 입력하세요... (예: 타이레놀과 아스피린)"):
        
        st.session_state.messages.append({"role": "user", "content": prompt})
        with st.chat_message("user"):
            st.markdown(prompt)

        reply_message = ""
        
        # 성분 질문
        # [수정-P1] '성분이 뭐야?' 질문 파싱
        match_component = re.match(r'(.+?)\s*성분[이]?[ ]?(뭐야|알려줘)\??', prompt.strip())
        if match_component:
            drug_name = match_component.group(1).strip('() ')
            if drug_name:
                results, drugs_set = find_drug_info(df, drug_name)
                if not results.empty:
                    # 'nan'이나 'none' 같은 문자열 제외
                    components = {str(d) for d in drugs_set if pd.notna(d) and len(str(d)) > 3 and str(d) != 'nan'}
                    if components:
                        reply_message = f"✅ '{drug_name}'의 관련 성분은 다음과 같습니다:\n\n* {', '.join(components)}"
                    else:
                        reply_message = f"ℹ️ '{drug_name}'을(를) 찾았으나, 연관된 성분 정보를 추출하지 못했습니다."
                else:
                    # [수정-P2] 메시지 수정
                    reply_message = f"ℹ️ '{drug_name}'에 대한 정보를 상호작용 데이터베이스에서 찾을 수 없습니다."
            else:
                reply_message = "❌ 어떤 약물의 성분을 알고 싶으신가요? 약물 이름을 입력해주세요."
        
        # 상호작용 질문
        # [수정-P1] '이랑', '랑', '과', '와', '하고' 등을 모두 처리
        match_interaction = re.match(r'(.+?)\s*(?:이랑|랑|과|와|하고)\s+(.+?)(?:를|을)?\s+(?:같이|함께)\s+(?:복용해도|먹어도)\s+(?:돼|되나|될까|되나요)\??', prompt.strip())
        
        if not match_interaction:
             # 간단한 형태: "약물A 약물B"
             match_interaction_simple = re.match(r'^\s*([^\s]+)\s+([^\s]+)\s*$', prompt.strip())
             if match_interaction_simple:
                 match_interaction = match_interaction_simple

        if match_interaction and not reply_message:
            drug_A_query = match_interaction.group(1).strip('() ')
            drug_B_query = match_interaction.group(2).strip('() ')
            
            if drug_A_query and drug_B_query:
                with st.spinner(f"🔄 '{drug_A_query}'와 '{drug_B_query}' 상호작용 검색 중..."):
                    risk, explanation = check_drug_interaction_flexible(df, drug_A_query, drug_B_query)
                
                # [수정-P2] "정보 없음" 메시지 커스터마이징
                if risk == "정보 없음":
                    reply_message = f"**💊 약물 상호작용 위험도: 정보 없음**\n\n**💡 상세 정보:**\n\n{explanation}에 대한 정보를 상호작용 데이터베이스에서 찾을 수 없습니다. (정보가 등록되지 않았습니다.)"
                else:
                    reply_message = f"**💊 약물 상호작용 위험도: {risk}**\n\n**💡 상세 정보:**\n\n{explanation}"
            else:
                reply_message = "❌ 두 약물 이름을 정확히 입력해주세요. 예: (A)약물과 (B)약물을 같이 복용해도 돼?"
        
        # 아무 패턴에도 해당하지 않는 경우
        elif not match_component and not match_interaction:
            reply_message = "🤔 죄송합니다. 질문 형식을 이해하지 못했습니다.\n\n   **[질문 예시]**\n   * 타이레놀과 아스피린\n   * 타이레놀 성분이 뭐야?"

        # 3. 챗봇의 응답을 채팅 기록에 추가하고 화면에 표시
        st.session_state.messages.append({"role": "assistant", "content": reply_message})
        with st.chat_message("assistant"):
            st.markdown(reply_message)

